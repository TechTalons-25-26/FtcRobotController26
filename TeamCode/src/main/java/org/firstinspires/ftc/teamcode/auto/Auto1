package org.firstinspires.ftc.teamcode.pedroPathing;

import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.CRServo;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.Servo;

import com.pedropathing.follower.Follower;
import com.pedropathing.geometry.Pose;
import org.firstinspires.ftc.teamcode.pedroPathing.Paths1;
import com.pedropathing.paths.PathChain;

@Autonomous(name = "IntegratedAutoTimed", group = "test drive")
public class Auto1 extends LinearOpMode {

    // ----- Drive Motors -----
    private DcMotor frontLeft, frontRight, backLeft, backRight;
    private DcMotor leftWheel, rightWheel;

    // ----- Mechanisms -----
    private DcMotor intakeMotor;
    private CRServo conveyor;
    private Servo outtakeAngle;

    // ----- PedroPathing -----
    private Follower follower;
    private Paths1 paths;

    // ----- Path State -----
    private int pathState = 0;

    // ----- Timed Mechanisms -----
    private long intakeEndTime = 0;
    private long conveyorEndTime = 0;
    private long outtakeEndTime = 0;

    @Override
    public void runOpMode() {
        robotSetup();

        // Initialize PedroPathing
        follower = Constants.createFollower(hardwareMap);
        paths = new Paths1(follower);
        follower.setStartingPose(new Pose(90, 8, Math.toRadians(90)));

        telemetry.addLine("Ready for start");
        telemetry.update();
        waitForStart();

        if (opModeIsActive()) {
            // Start first path
            follower.followPath(paths.Path1);
            pathState = 1;

            while (opModeIsActive()) {
                // Update PedroPathing follower
                follower.update();

                // Update timed mechanisms
                updateMechanisms();

                // Run state machine for paths
                switch (pathState) {
                    case 1:
                        // Example: run intake/conveyor during Path1
                        if (intakeEndTime == 0) {
                            rollIntake(1.0, 2000);   // 2 seconds
                            rollConveyor(0.5, 2000); // 2 seconds
                        }

                        if (!follower.isBusy()) {
                            follower.followPath(paths.Path2);
                            pathState = 2;
                        }
                        break;

                    case 2:
                        // Example: run outtake wheels for 1.5 seconds during Path2
                        if (outtakeEndTime == 0) {
                            rollOuttake(0.5, 1500);
                        }

                        if (!follower.isBusy()) {
                            follower.followPath(paths.Path3);
                            pathState = 3;
                        }
                        break;

                    case 3:
                        if (!follower.isBusy()) {
                            follower.followPath(paths.Path4);
                            pathState = 4;
                        }
                        break;

                    case 4:
                        if (!follower.isBusy()) {
                            pathState = -1; // Done
                        }
                        break;
                }

                // Telemetry for debugging
                telemetry.addData("Path State", pathState);
                telemetry.addData("X", follower.getPose().getX());
                telemetry.addData("Y", follower.getPose().getY());
                telemetry.addData("Heading", follower.getPose().getHeading());
                telemetry.update();
            }
        }

        stopWheelMotors();
    }

    // ----- Hardware Setup -----
    private void robotSetup() {
        leftWheel = hardwareMap.get(DcMotor.class, "leftWheel");
        rightWheel = hardwareMap.get(DcMotor.class, "rightWheel");
        intakeMotor = hardwareMap.get(DcMotor.class, "intakeMotor");
        conveyor = hardwareMap.get(CRServo.class, "conveyor");
        outtakeAngle = hardwareMap.get(Servo.class, "outtakeAngle");

        rightWheel.setDirection(DcMotor.Direction.REVERSE);

        frontLeft = hardwareMap.get(DcMotor.class, "frontLeft");
        frontRight = hardwareMap.get(DcMotor.class, "frontRight");
        backLeft = hardwareMap.get(DcMotor.class, "backLeft");
        backRight = hardwareMap.get(DcMotor.class, "backRight");

        frontLeft.setDirection(DcMotor.Direction.FORWARD);
        frontRight.setDirection(DcMotor.Direction.REVERSE);
        backLeft.setDirection(DcMotor.Direction.FORWARD);
        backRight.setDirection(DcMotor.Direction.REVERSE);

        stopWheelMotors();

        frontLeft.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        frontRight.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        backLeft.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        backRight.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
    }

    private void stopWheelMotors() {
        frontLeft.setPower(0);
        frontRight.setPower(0);
        backLeft.setPower(0);
        backRight.setPower(0);
    }

    // ----- Timed Mechanism Methods -----
    public void rollIntake(double speed, long durationMS) {
        intakeMotor.setPower(speed);
        intakeEndTime = System.currentTimeMillis() + durationMS;
    }

    public void rollConveyor(double speed, long durationMS) {
        conveyor.setPower(speed);
        conveyorEndTime = System.currentTimeMillis() + durationMS;
    }

    public void rollOuttake(double speed, long durationMS) {
        leftWheel.setPower(speed);
        rightWheel.setPower(speed);
        outtakeEndTime = System.currentTimeMillis() + durationMS;
    }

    private void updateMechanisms() {
        if (System.currentTimeMillis() > intakeEndTime) {
            intakeMotor.setPower(0);
            intakeEndTime = 0;
        }

        if (System.currentTimeMillis() > conveyorEndTime) {
            conveyor.setPower(0);
            conveyorEndTime = 0;
        }

        if (System.currentTimeMillis() > outtakeEndTime) {
            leftWheel.setPower(0);
            rightWheel.setPower(0);
            outtakeEndTime = 0;
        }
    }
}
